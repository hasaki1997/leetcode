## Longest Increasing Subsequence

### label: `dp`

Given an unsorted array of integers, find the length of longest increasing subsequence.

**Example:**

```
Input: [10,9,2,5,3,7,101,18]
Output: 4 
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
```

**Note:**

- There may be more than one LIS combination, it is only necessary for you to return the length.
- Your algorithm should run in O(*n2*) complexity.

**Follow up:** Could you improve it to O(*n* log *n*) time complexity?

**方法一**:dp

dp[n] = max{1,dp[i]+1}

代码:

``` python
def lengthOfLIS(nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    length = len(nums)
    dp = [0]*length
    for i in range(length):
        maxnum = 1
        for j in range(0,i):
            if nums[i]>nums[j]:
                maxnum = max(maxnum,dp[j]+1)
        dp[i] = maxnum
    r = 0
    for i in range(length):
        r = max(r,dp[i])
    print(r)
    return r
```

**方法二**:来自leetcode

`tails` is an array storing(储存) the smallest tail of all increasing subsequences with length `i+1` in `tails[i]`.
For example, say we have `nums = [4,5,6,3]`, then all the available increasing subsequences are:

定义一个 tails 数组，其中 tails[i] 存储长度为 i + 1 的最长递增子序列的最后一个元素。如果有多个长度相等的最长递增子序列，那么 tails[i] 就取最小值。例如对于数组 [4,5,6,3]，有

```
len = 1   :      [4], [5], [6], [3]   => tails[0] = 3
len = 2   :      [4, 5], [5, 6]       => tails[1] = 5
len = 3   :      [4, 5, 6]            => tails[2] = 6
```

We can easily prove(证明) that tails is a increasing array. Therefore it is possible to do a binary search in tails array to find the one needs update.

Each time we only do one of the two:

```
(1) if x is larger than all tails, append it, increase the size by 1
(2) if tails[i-1] < x <= tails[i], update tails[i]
```

Doing so will maintain the tails invariant. The the final answer is just the size.

```python
def lengthOfLIS(self, nums):
    tails = [0] * len(nums)
    size = 0
    for x in nums:
        i, j = 0, size
        while i != j:
            m = (i + j) / 2
            if tails[m] < x:
                i = m + 1
            else:
                j = m
        tails[i] = x
        size = max(i + 1, size)
    return size
```

 ```js
const lengthOfLIS = function(nums) {
  let tails = [],
    len = 0,
    first,
    last,
    mid;
  for (let i = 0, ii = nums.length; i < ii; ++i) {
    first = 0;
    last = len;
    while (first < last) {
      mid = parseInt((first + last) / 2);
      console.log(nums[i], tails[mid],nums[i] > tails[mid]);
      if (nums[i] > tails[mid]) {
        first = mid + 1;
      } else {
        last = mid;
      }
    }
    tails[last] = nums[i];
    if (last === len) {
      ++len;
    }
  }
  return len;
};
 ```



一个通俗易懂的解释,来自[Felix021](https://www.felix021.com/blog/read.php?1587)

假设存在一个序列d[1..9] = 2 1 5 3 6 4 8 9 7，可以看出来它的LIS长度为5。 下面一步一步试着找出它。 我们定义一个序列B，然后令 i = 1 to 9 逐个考察这个序列。 此外，我们用一个变量Len来记录现在最长算到多少了  

首先，把d[1]有序地放到B里，令B[1] = 2，就是说当只有1一个数字2的时候，长度为1的LIS的最小末尾是2。这时Len=1  

然后，把d[2]有序地放到B里，令B[1] = 1，就是说长度为1的LIS的最小末尾是1，d[1]=2已经没用了，很容易理解吧。这时Len=1  

接着，d[3] = 5，d[3]>B[1]，所以令B[1+1]=B[2]=d[3]=5，就是说长度为2的LIS的最小末尾是5，很容易理解吧。这时候B[1..2] = 1, 5，Len＝2  

再来，d[4] = 3，它正好加在1,5之间，放在1的位置显然不合适，因为1小于3，长度为1的LIS最小末尾应该是1，这样很容易推知，长度为2的LIS最小末尾是3，于是可以把5淘汰掉，这时候B[1..2] = 1, 3，Len = 2  

继续，d[5] = 6，它在3后面，因为B[2] = 3, 而6在3后面，于是很容易可以推知B[3] = 6, 这时B[1..3] = 1, 3, 6，还是很容易理解吧？ Len = 3 了噢。 

 第6个, d[6] = 4，你看它在3和6之间，于是我们就可以把6替换掉，得到B[3] = 4。B[1..3] = 1, 3, 4， Len继续等于3  

第7个, d[7] = 8，它很大，比4大，嗯。于是B[4] = 8。Len变成4了  

第8个, d[8] = 9，得到B[5] = 9，嗯。Len继续增大，到5了。  

最后一个, d[9] = 7，它在B[3] = 4和B[4] = 8之间，所以我们知道，最新的B[4] =7，B[1..5] = 1, 3, 4, 7, 9，Len = 5。  于是我们知道了LIS的长度为5。 

 !!!!! 注意。这个1,3,4,7,9不是LIS，它只是存储的对应长度LIS的最小末尾。有了这个末尾，我们就可以一个一个地插入数据。虽然最后一个d[9] = 7更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9，那么就可以把8更新到d[5], 9更新到d[6]，得出LIS的长度为6。  然后应该发现一件事情了：在B中插入数据是有序的，而且是进行替换而不需要挪动——也就是说，我们可以使用二分查找，将每一个数字的插入时间优化到O(logN)~~~~~于是算法的时间复杂度就降低到了O(NlogN)～！